import ast
import vec
import utils
import group
import inputs
import config

/// All scopes that need their parent scopes
relation NeedsScopeParents(scope: ScopeId)

/// All scopes that need their child scopes
relation NeedsScopeChildren(scope: ScopeId)

/// Build the scope graph, unrolling the parent<-child relationships to full trees
///
/// Given
/// ```
/// a<-b
/// b<-c
/// b<-d
/// ```
/// It will produce
/// ```
/// a
/// ├-b
/// │ └┐  
/// │  ├╴c
/// │  └╴d 
/// ├╴c
/// └╴d
/// ```
///
relation ScopeFamily(parent: ScopeId, child: ScopeId)
index ScopeFamilyByParent(parent: ScopeId) on ScopeFamily(parent, _)

ScopeFamily(parent, child) :-
    NeedsScopeChildren(parent),
    InputScope(parent, child),
    parent != child.

ScopeFamily(parent, child) :-
    NeedsScopeParents(child),
    InputScope(parent, child),
    parent != child.

ScopeFamily(parent, child) :-
    InputScope(interum, child),
    ScopeFamily(parent, interum),
    parent != child.

// TODO: Are other things hoistable?
relation IsHoistable(id: AnyId, hoistable: bool)
IsHoistable(AnyIdFunc { id }, true) :- Function(id, _, _, _, _).
IsHoistable(AnyIdStmt { id }, true) :- VarDecl(id, _, _, _).

// Function-level scoping, the scope of the nearest getter, setter,
// method, function, arrow function or file/module
// TODO: Make this top-down
relation FunctionLevelScope(
    // An arbitrary scope to get the closest function-level scope
    scope: ScopeId,
    // The nearest function-level scope
    nearest: ScopeId,
    // The id of the function/file/etc the scope belongs to
    id: AnyId,
)

FunctionLevelScope(scope, scope, AnyIdFile { file }) :-
    File(file, _, scope).

// Functions
FunctionLevelScope(body, body, AnyIdFunc { func }) :-
    Function(func, _, _, body, _).

// Class methods
FunctionLevelScope(scope, scope, AnyIdClass { class }) :-
    Class(class, _, _, Some { elements }, _, _),
    var body = FlatMap(elements.filter_map(|elem| elem.ival().body())),
    Statement(body, _, scope, _).

// Class expression methods
FunctionLevelScope(scope, scope, AnyIdExpr { expr }) :-
    ClassExpr(expr, Some { elements }),
    var body = FlatMap(elements.filter_map(|elem| elem.ival().body())),
    Statement(body, _, scope, _).

// Function expressions
FunctionLevelScope(scope, scope, AnyIdExpr { expr }) :-
    InlineFunc(expr, _, Some { body }),
    Statement(body, _, scope, _).

// Getters & setters
FunctionLevelScope(scope, scope, AnyIdExpr { expr }) :-
    Property(expr, _, Some { val }),
    Some { var body } = val.body(),
    Statement(body, _, scope, _).

// Arrow functions
FunctionLevelScope(scope, scope, AnyIdExpr { expr }) :-
    Arrow(expr, Some { (_, scope) }).

// FIXME: This still causes duplication because `parent` isn't included in
//        the aggregate, but I can't be fucked right now
FunctionLevelScope(child, scope, id) :-
    FunctionLevelScope(parent, scope, id),
    InputScope(parent, child),
    (var scope, var id) = (scope, id).group_by((child)).arg_max(|scope| scope.0).

relation ScopeOfId(id: AnyId, scope: ScopeId)
ScopeOfId(AnyIdFile { id }, scope) :- File(id, _, scope).
ScopeOfId(AnyIdFunc { id }, scope) :- Function(id, _, scope, _, _).
ScopeOfId(AnyIdClass { id }, scope) :- Class(id, _, _, _, scope, _).
ScopeOfId(AnyIdStmt { id }, scope) :- Statement(id, _, scope, _).
ScopeOfId(AnyIdExpr { id }, scope) :- Expression(id, _, scope, _).
ScopeOfId(AnyIdImport { id }, scope) :- ImportDecl(id @ ImportId { _, file }, _), File(file, _, scope).
