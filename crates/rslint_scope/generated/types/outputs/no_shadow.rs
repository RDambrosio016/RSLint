#![allow(
    path_statements,
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::missing_safety_doc,
    clippy::match_single_binding,
    clippy::ptr_arg,
    clippy::redundant_closure,
    clippy::needless_lifetimes,
    clippy::borrowed_box,
    clippy::map_clone,
    clippy::toplevel_ref_arg,
    clippy::double_parens,
    clippy::collapsible_if,
    clippy::clone_on_copy,
    clippy::unused_unit,
    clippy::deref_addrof,
    clippy::clone_on_copy,
    clippy::needless_return,
    clippy::op_ref,
    clippy::match_like_matches_macro,
    clippy::comparison_chain,
    clippy::len_zero,
    clippy::extra_unused_lifetimes
)]

use ::num::One;
use ::std::ops::Deref;

use ::differential_dataflow::collection;
use ::timely::communication;
use ::timely::dataflow::scopes;
use ::timely::worker;

use ::ddlog_derive::{FromRecord, IntoRecord, Mutator};
use ::differential_datalog::ddval::DDValue;
use ::differential_datalog::ddval::DDValConvert;
use ::differential_datalog::program;
use ::differential_datalog::program::TupleTS;
use ::differential_datalog::program::XFormArrangement;
use ::differential_datalog::program::XFormCollection;
use ::differential_datalog::program::Weight;
use ::differential_datalog::record::FromRecord;
use ::differential_datalog::record::IntoRecord;
use ::differential_datalog::record::Mutator;
use ::serde::Deserialize;
use ::serde::Serialize;


// `usize` and `isize` are builtin Rust types; we therefore declare an alias to DDlog's `usize` and
// `isize`.
pub type std_usize = u64;
pub type std_isize = i64;


#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, IntoRecord, Mutator, Default, Serialize, Deserialize, FromRecord)]
#[ddlog(rename = "outputs::no_shadow::DeclarationInDescendent")]
pub struct DeclarationInDescendent {
    pub scope: types__ast::ScopeId,
    pub name: types__ast::Name,
    pub id: types__ast::AnyId
}
impl abomonation::Abomonation for DeclarationInDescendent{}
impl ::std::fmt::Display for DeclarationInDescendent {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            DeclarationInDescendent{scope,name,id} => {
                __formatter.write_str("outputs::no_shadow::DeclarationInDescendent{")?;
                ::std::fmt::Debug::fmt(scope, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for DeclarationInDescendent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, IntoRecord, Mutator, Default, Serialize, Deserialize, FromRecord)]
#[ddlog(rename = "outputs::no_shadow::NoShadow")]
pub struct NoShadow {
    pub variable: types__ast::Name,
    pub original: ddlog_std::tuple2<types__ast::AnyId, types__ast::Span>,
    pub shadower: ddlog_std::tuple2<types__ast::AnyId, types__ast::Span>,
    pub implicit: bool
}
impl abomonation::Abomonation for NoShadow{}
impl ::std::fmt::Display for NoShadow {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            NoShadow{variable,original,shadower,implicit} => {
                __formatter.write_str("outputs::no_shadow::NoShadow{")?;
                ::std::fmt::Debug::fmt(variable, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(original, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(shadower, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(implicit, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for NoShadow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, IntoRecord, Mutator, Default, Serialize, Deserialize, FromRecord)]
#[ddlog(rename = "outputs::no_shadow::ScopeOfDecl")]
pub struct ScopeOfDecl {
    pub scope: types__ast::ScopeId,
    pub declared: types__ast::AnyId
}
impl abomonation::Abomonation for ScopeOfDecl{}
impl ::std::fmt::Display for ScopeOfDecl {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            ScopeOfDecl{scope,declared} => {
                __formatter.write_str("outputs::no_shadow::ScopeOfDecl{")?;
                ::std::fmt::Debug::fmt(scope, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(declared, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for ScopeOfDecl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
pub static __Arng_outputs_no_shadow_ScopeOfDecl_0 : ::once_cell::sync::Lazy<program::Arrangement> = ::once_cell::sync::Lazy::new(|| program::Arrangement::Map{
                                                                                                                                       name: std::borrow::Cow::from(r###"(outputs::no_shadow::ScopeOfDecl{.scope=(ast::ScopeId{.id=(_: bit<32>), .file=(_0: ast::FileId)}: ast::ScopeId), .declared=(_: ast::AnyId)}: outputs::no_shadow::ScopeOfDecl) /*join*/"###),
                                                                                                                                        afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                        {
                                                                                                                                            let __cloned = __v.clone();
                                                                                                                                            match < ScopeOfDecl>::from_ddvalue(__v) {
                                                                                                                                                ScopeOfDecl{scope: types__ast::ScopeId{id: _, file: ref _0}, declared: _} => Some(((*_0).clone()).into_ddvalue()),
                                                                                                                                                _ => None
                                                                                                                                            }.map(|x|(x,__cloned))
                                                                                                                                        }
                                                                                                                                        __f},
                                                                                                                                        queryable: false
                                                                                                                                    });
pub static __Arng_outputs_no_shadow_DeclarationInDescendent_0 : ::once_cell::sync::Lazy<program::Arrangement> = ::once_cell::sync::Lazy::new(|| program::Arrangement::Map{
                                                                                                                                                   name: std::borrow::Cow::from(r###"(outputs::no_shadow::DeclarationInDescendent{.scope=(_0: ast::ScopeId), .name=(_: internment::Intern<string>), .id=(_: ast::AnyId)}: outputs::no_shadow::DeclarationInDescendent) /*join*/"###),
                                                                                                                                                    afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                    {
                                                                                                                                                        let __cloned = __v.clone();
                                                                                                                                                        match < DeclarationInDescendent>::from_ddvalue(__v) {
                                                                                                                                                            DeclarationInDescendent{scope: ref _0, name: _, id: _} => Some(((*_0).clone()).into_ddvalue()),
                                                                                                                                                            _ => None
                                                                                                                                                        }.map(|x|(x,__cloned))
                                                                                                                                                    }
                                                                                                                                                    __f},
                                                                                                                                                    queryable: false
                                                                                                                                                });
pub static __Rule_outputs_no_shadow_ScopeOfDecl_0 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::no_shadow::ScopeOfDecl[(outputs::no_shadow::ScopeOfDecl{.scope=scope, .declared=declared}: outputs::no_shadow::ScopeOfDecl)] :- config::EnableNoShadow[(config::EnableNoShadow{.file=(file: ast::FileId), .config=(config: ddlog_std::Ref<config::NoShadowConfig>)}: config::EnableNoShadow)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.name=(_: internment::Intern<string>), .scope=(decl_scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((not (ast::is_global(declared))) and ((ast::file(declared)) == (ddlog_std::Some{.x=file}: ddlog_std::Option<ast::FileId>))), ((var scope: ast::ScopeId) = if (config::hoisting_enabled(((ddlog_std::deref: function(ddlog_std::Ref<config::NoShadowConfig>):config::NoShadowConfig)(config)))) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (var_decls::hoisted_scope(decl_scope))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          } else {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                (var_decls::unhoisted_scope(decl_scope))
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }). */
                                                                                                                             program::Rule::ArrangementRule {
                                                                                                                                 description: std::borrow::Cow::from( "outputs::no_shadow::ScopeOfDecl(.scope=scope, .declared=declared) :- config::EnableNoShadow(.file=file, .config=config), var_decls::VariableDeclarations(.name=_, .scope=decl_scope, .declared_in=declared, .meta=_), ((not (ast::is_global(declared))) and ((ast::file(declared)) == ddlog_std::Some{.x=file})), (var scope = if (config::hoisting_enabled((ddlog_std::deref(config)))) {\n                                                                                                                                                                                                                                                                                                                                   (var_decls::hoisted_scope(decl_scope))\n                                                                                                                                                                                                                                                                                                                               } else {\n                                                                                                                                                                                                                                                                                                                                     (var_decls::unhoisted_scope(decl_scope))\n                                                                                                                                                                                                                                                                                                                                 })."),
                                                                                                                                 arr: ( 1, 1),
                                                                                                                                 xform: XFormArrangement::Join{
                                                                                                                                            description: std::borrow::Cow::from("config::EnableNoShadow(.file=file, .config=config), var_decls::VariableDeclarations(.name=_, .scope=decl_scope, .declared_in=declared, .meta=_)"),
                                                                                                                                            ffun: None,
                                                                                                                                            arrangement: (86,3),
                                                                                                                                            jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                            {
                                                                                                                                                let (ref file, ref config) = match *<types__config::EnableNoShadow>::from_ddvalue_ref(__v1) {
                                                                                                                                                    types__config::EnableNoShadow{file: ref file, config: ref config} => ((*file).clone(), (*config).clone()),
                                                                                                                                                    _ => return None
                                                                                                                                                };
                                                                                                                                                let (ref decl_scope, ref declared) = match *<crate::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                                    crate::var_decls::VariableDeclarations{name: _, scope: ref decl_scope, declared_in: ref declared, meta: _} => ((*decl_scope).clone(), (*declared).clone()),
                                                                                                                                                    _ => return None
                                                                                                                                                };
                                                                                                                                                if !((!types__ast::is_global(declared)) && ((&*(&types__ast::file(declared))) == (&*(&(ddlog_std::Option::Some{x: (*file).clone()}))))) {return None;};
                                                                                                                                                let ref scope: types__ast::ScopeId = match if types__config::hoisting_enabled(ddlog_std::deref(config)) {
                                                                                                                                                                                               crate::var_decls::hoisted_scope(decl_scope)
                                                                                                                                                                                           } else {
                                                                                                                                                                                               crate::var_decls::unhoisted_scope(decl_scope)
                                                                                                                                                                                           } {
                                                                                                                                                    scope => scope,
                                                                                                                                                    _ => return None
                                                                                                                                                };
                                                                                                                                                Some(((ScopeOfDecl{scope: (*scope).clone(), declared: (*declared).clone()})).into_ddvalue())
                                                                                                                                            }
                                                                                                                                            __f},
                                                                                                                                            next: Box::new(None)
                                                                                                                                        }
                                                                                                                             });
pub static __Rule_outputs_no_shadow_DeclarationInDescendent_0 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::no_shadow::DeclarationInDescendent[(outputs::no_shadow::DeclarationInDescendent{.scope=scope, .name=name, .id=id}: outputs::no_shadow::DeclarationInDescendent)] :- config::EnableNoShadow[(config::EnableNoShadow{.file=(file: ast::FileId), .config=(_: ddlog_std::Ref<config::NoShadowConfig>)}: config::EnableNoShadow)], outputs::no_shadow::ScopeOfDecl[(outputs::no_shadow::ScopeOfDecl{.scope=(scope@ (ast::ScopeId{.id=(_: bit<32>), .file=(file: ast::FileId)}: ast::ScopeId)), .declared=(id: ast::AnyId)}: outputs::no_shadow::ScopeOfDecl)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.name=(name: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(id: ast::AnyId), .meta=(_: ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)]. */
                                                                                                                                         program::Rule::ArrangementRule {
                                                                                                                                             description: std::borrow::Cow::from( "outputs::no_shadow::DeclarationInDescendent(.scope=scope, .name=name, .id=id) :- config::EnableNoShadow(.file=file, .config=_), outputs::no_shadow::ScopeOfDecl(.scope=(scope@ ast::ScopeId{.id=_, .file=file}), .declared=id), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=id, .meta=_)."),
                                                                                                                                             arr: ( 1, 0),
                                                                                                                                             xform: XFormArrangement::Join{
                                                                                                                                                        description: std::borrow::Cow::from("config::EnableNoShadow(.file=file, .config=_), outputs::no_shadow::ScopeOfDecl(.scope=(scope@ ast::ScopeId{.id=_, .file=file}), .declared=id)"),
                                                                                                                                                        ffun: None,
                                                                                                                                                        arrangement: (66,0),
                                                                                                                                                        jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                        {
                                                                                                                                                            let ref file = match *<types__config::EnableNoShadow>::from_ddvalue_ref(__v1) {
                                                                                                                                                                types__config::EnableNoShadow{file: ref file, config: _} => (*file).clone(),
                                                                                                                                                                _ => return None
                                                                                                                                                            };
                                                                                                                                                            let (ref scope, ref id) = match *<ScopeOfDecl>::from_ddvalue_ref(__v2) {
                                                                                                                                                                ScopeOfDecl{scope: ref scope, declared: ref id} => match scope {
                                                                                                                                                                                                                       types__ast::ScopeId{id: _, file: _} => ((*scope).clone(), (*id).clone()),
                                                                                                                                                                                                                       _ => return None
                                                                                                                                                                                                                   },
                                                                                                                                                                _ => return None
                                                                                                                                                            };
                                                                                                                                                            Some((ddlog_std::tuple2((*scope).clone(), (*id).clone())).into_ddvalue())
                                                                                                                                                        }
                                                                                                                                                        __f},
                                                                                                                                                        next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                description: std::borrow::Cow::from("arrange config::EnableNoShadow(.file=file, .config=_), outputs::no_shadow::ScopeOfDecl(.scope=(scope@ ast::ScopeId{.id=_, .file=file}), .declared=id) by (id)"),
                                                                                                                                                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                {
                                                                                                                                                                                    let ddlog_std::tuple2(ref scope, ref id) = *<ddlog_std::tuple2<types__ast::ScopeId, types__ast::AnyId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                    Some((((*id).clone()).into_ddvalue(), (ddlog_std::tuple2((*scope).clone(), (*id).clone())).into_ddvalue()))
                                                                                                                                                                                }
                                                                                                                                                                                __f},
                                                                                                                                                                                next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                   description: std::borrow::Cow::from("config::EnableNoShadow(.file=file, .config=_), outputs::no_shadow::ScopeOfDecl(.scope=(scope@ ast::ScopeId{.id=_, .file=file}), .declared=id), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=id, .meta=_)"),
                                                                                                                                                                                                   ffun: None,
                                                                                                                                                                                                   arrangement: (86,1),
                                                                                                                                                                                                   jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                   {
                                                                                                                                                                                                       let ddlog_std::tuple2(ref scope, ref id) = *<ddlog_std::tuple2<types__ast::ScopeId, types__ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                       let ref name = match *<crate::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                           crate::var_decls::VariableDeclarations{name: ref name, scope: _, declared_in: _, meta: _} => (*name).clone(),
                                                                                                                                                                                                           _ => return None
                                                                                                                                                                                                       };
                                                                                                                                                                                                       Some(((DeclarationInDescendent{scope: (*scope).clone(), name: (*name).clone(), id: (*id).clone()})).into_ddvalue())
                                                                                                                                                                                                   }
                                                                                                                                                                                                   __f},
                                                                                                                                                                                                   next: Box::new(None)
                                                                                                                                                                                               })
                                                                                                                                                                            }))
                                                                                                                                                    }
                                                                                                                                         });
pub static __Rule_outputs_no_shadow_DeclarationInDescendent_1 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::no_shadow::DeclarationInDescendent[(outputs::no_shadow::DeclarationInDescendent{.scope=parent, .name=name, .id=id}: outputs::no_shadow::DeclarationInDescendent)] :- outputs::no_shadow::DeclarationInDescendent[(outputs::no_shadow::DeclarationInDescendent{.scope=(child: ast::ScopeId), .name=(name: internment::Intern<string>), .id=(id: ast::AnyId)}: outputs::no_shadow::DeclarationInDescendent)], inputs::InputScope[(inputs::InputScope{.parent=(parent: ast::ScopeId), .child=(child: ast::ScopeId)}: inputs::InputScope)]. */
                                                                                                                                         program::Rule::ArrangementRule {
                                                                                                                                             description: std::borrow::Cow::from( "outputs::no_shadow::DeclarationInDescendent(.scope=parent, .name=name, .id=id) :- outputs::no_shadow::DeclarationInDescendent(.scope=child, .name=name, .id=id), inputs::InputScope(.parent=parent, .child=child)."),
                                                                                                                                             arr: ( 64, 0),
                                                                                                                                             xform: XFormArrangement::Join{
                                                                                                                                                        description: std::borrow::Cow::from("outputs::no_shadow::DeclarationInDescendent(.scope=child, .name=name, .id=id), inputs::InputScope(.parent=parent, .child=child)"),
                                                                                                                                                        ffun: None,
                                                                                                                                                        arrangement: (40,0),
                                                                                                                                                        jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                        {
                                                                                                                                                            let (ref child, ref name, ref id) = match *<DeclarationInDescendent>::from_ddvalue_ref(__v1) {
                                                                                                                                                                DeclarationInDescendent{scope: ref child, name: ref name, id: ref id} => ((*child).clone(), (*name).clone(), (*id).clone()),
                                                                                                                                                                _ => return None
                                                                                                                                                            };
                                                                                                                                                            let ref parent = match *<types__inputs::InputScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                                types__inputs::InputScope{parent: ref parent, child: _} => (*parent).clone(),
                                                                                                                                                                _ => return None
                                                                                                                                                            };
                                                                                                                                                            Some(((DeclarationInDescendent{scope: (*parent).clone(), name: (*name).clone(), id: (*id).clone()})).into_ddvalue())
                                                                                                                                                        }
                                                                                                                                                        __f},
                                                                                                                                                        next: Box::new(None)
                                                                                                                                                    }
                                                                                                                                         });
pub static __Rule_outputs_no_shadow_NoShadow_0 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::no_shadow::NoShadow[(outputs::no_shadow::NoShadow{.variable=name, .original=(shadowed_id, shadowed_span), .shadower=(shadower_id, shadower_span), .implicit=false}: outputs::no_shadow::NoShadow)] :- config::EnableNoShadow[(config::EnableNoShadow{.file=(file: ast::FileId), .config=(config: ddlog_std::Ref<config::NoShadowConfig>)}: config::EnableNoShadow)], outputs::no_shadow::ScopeOfDecl[(outputs::no_shadow::ScopeOfDecl{.scope=(shadowed_scope@ (ast::ScopeId{.id=(_: bit<32>), .file=(file: ast::FileId)}: ast::ScopeId)), .declared=(shadowed_id: ast::AnyId)}: outputs::no_shadow::ScopeOfDecl)], outputs::no_shadow::DeclarationInDescendent[(outputs::no_shadow::DeclarationInDescendent{.scope=(shadowed_scope: ast::ScopeId), .name=(name: internment::Intern<string>), .id=(shadower_id: ast::AnyId)}: outputs::no_shadow::DeclarationInDescendent)], (shadowed_id != shadower_id), var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.name=(name: internment::Intern<string>), .scope=(shadowed_scope_raw: var_decls::DeclarationScope), .declared_in=(shadowed_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(shadowed_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.name=(name: internment::Intern<string>), .scope=(shadower_scope_raw: var_decls::DeclarationScope), .declared_in=(shadower_id: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=(_: bool), .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(shadower_span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], match (((config::hoisting_enabled(((ddlog_std::deref: function(ddlog_std::Ref<config::NoShadowConfig>):config::NoShadowConfig)(config)))), (var_decls::is_hoistable(shadower_scope_raw)), (var_decls::is_hoistable(shadowed_scope_raw)))) {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (true, true, true) -> (shadower_span < shadowed_span),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (true, false, true) -> (shadower_span < shadowed_span),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    (true, true, false) -> (shadower_span < shadowed_span),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ((_: bool), (_: bool), (_: bool)) -> true
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }. */
                                                                                                                          program::Rule::ArrangementRule {
                                                                                                                              description: std::borrow::Cow::from( "outputs::no_shadow::NoShadow(.variable=name, .original=(shadowed_id, shadowed_span), .shadower=(shadower_id, shadower_span), .implicit=false) :- config::EnableNoShadow(.file=file, .config=config), outputs::no_shadow::ScopeOfDecl(.scope=(shadowed_scope@ ast::ScopeId{.id=_, .file=file}), .declared=shadowed_id), outputs::no_shadow::DeclarationInDescendent(.scope=shadowed_scope, .name=name, .id=shadower_id), (shadowed_id != shadower_id), var_decls::VariableDeclarations(.name=name, .scope=shadowed_scope_raw, .declared_in=shadowed_id, .meta=(&var_decls::VariableMeta{.is_function_argument=_, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=shadowed_span}})), var_decls::VariableDeclarations(.name=name, .scope=shadower_scope_raw, .declared_in=shadower_id, .meta=(&var_decls::VariableMeta{.is_function_argument=_, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=shadower_span}})), match (((config::hoisting_enabled((ddlog_std::deref(config)))), (var_decls::is_hoistable(shadower_scope_raw)), (var_decls::is_hoistable(shadowed_scope_raw)))) {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (true, true, true) -> (shadower_span < shadowed_span),\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (true, false, true) -> (shadower_span < shadowed_span),\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (true, true, false) -> (shadower_span < shadowed_span),\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      (_, _, _) -> true\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  }."),
                                                                                                                              arr: ( 1, 0),
                                                                                                                              xform: XFormArrangement::Join{
                                                                                                                                         description: std::borrow::Cow::from("config::EnableNoShadow(.file=file, .config=config), outputs::no_shadow::ScopeOfDecl(.scope=(shadowed_scope@ ast::ScopeId{.id=_, .file=file}), .declared=shadowed_id)"),
                                                                                                                                         ffun: None,
                                                                                                                                         arrangement: (66,0),
                                                                                                                                         jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                         {
                                                                                                                                             let (ref file, ref config) = match *<types__config::EnableNoShadow>::from_ddvalue_ref(__v1) {
                                                                                                                                                 types__config::EnableNoShadow{file: ref file, config: ref config} => ((*file).clone(), (*config).clone()),
                                                                                                                                                 _ => return None
                                                                                                                                             };
                                                                                                                                             let (ref shadowed_scope, ref shadowed_id) = match *<ScopeOfDecl>::from_ddvalue_ref(__v2) {
                                                                                                                                                 ScopeOfDecl{scope: ref shadowed_scope, declared: ref shadowed_id} => match shadowed_scope {
                                                                                                                                                                                                                          types__ast::ScopeId{id: _, file: _} => ((*shadowed_scope).clone(), (*shadowed_id).clone()),
                                                                                                                                                                                                                          _ => return None
                                                                                                                                                                                                                      },
                                                                                                                                                 _ => return None
                                                                                                                                             };
                                                                                                                                             Some((ddlog_std::tuple3((*config).clone(), (*shadowed_scope).clone(), (*shadowed_id).clone())).into_ddvalue())
                                                                                                                                         }
                                                                                                                                         __f},
                                                                                                                                         next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                 description: std::borrow::Cow::from("arrange config::EnableNoShadow(.file=file, .config=config), outputs::no_shadow::ScopeOfDecl(.scope=(shadowed_scope@ ast::ScopeId{.id=_, .file=file}), .declared=shadowed_id) by (shadowed_scope)"),
                                                                                                                                                                 afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                 {
                                                                                                                                                                     let ddlog_std::tuple3(ref config, ref shadowed_scope, ref shadowed_id) = *<ddlog_std::tuple3<ddlog_std::Ref<types__config::NoShadowConfig>, types__ast::ScopeId, types__ast::AnyId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                     Some((((*shadowed_scope).clone()).into_ddvalue(), (ddlog_std::tuple2((*config).clone(), (*shadowed_id).clone())).into_ddvalue()))
                                                                                                                                                                 }
                                                                                                                                                                 __f},
                                                                                                                                                                 next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                    description: std::borrow::Cow::from("config::EnableNoShadow(.file=file, .config=config), outputs::no_shadow::ScopeOfDecl(.scope=(shadowed_scope@ ast::ScopeId{.id=_, .file=file}), .declared=shadowed_id), outputs::no_shadow::DeclarationInDescendent(.scope=shadowed_scope, .name=name, .id=shadower_id)"),
                                                                                                                                                                                    ffun: None,
                                                                                                                                                                                    arrangement: (64,0),
                                                                                                                                                                                    jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                    {
                                                                                                                                                                                        let ddlog_std::tuple2(ref config, ref shadowed_id) = *<ddlog_std::tuple2<ddlog_std::Ref<types__config::NoShadowConfig>, types__ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                        let (ref name, ref shadower_id) = match *<DeclarationInDescendent>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                            DeclarationInDescendent{scope: _, name: ref name, id: ref shadower_id} => ((*name).clone(), (*shadower_id).clone()),
                                                                                                                                                                                            _ => return None
                                                                                                                                                                                        };
                                                                                                                                                                                        if !((&*shadowed_id) != (&*shadower_id)) {return None;};
                                                                                                                                                                                        Some((ddlog_std::tuple4((*config).clone(), (*shadowed_id).clone(), (*name).clone(), (*shadower_id).clone())).into_ddvalue())
                                                                                                                                                                                    }
                                                                                                                                                                                    __f},
                                                                                                                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                            description: std::borrow::Cow::from("arrange config::EnableNoShadow(.file=file, .config=config), outputs::no_shadow::ScopeOfDecl(.scope=(shadowed_scope@ ast::ScopeId{.id=_, .file=file}), .declared=shadowed_id), outputs::no_shadow::DeclarationInDescendent(.scope=shadowed_scope, .name=name, .id=shadower_id), (shadowed_id != shadower_id) by (name, shadowed_id)"),
                                                                                                                                                                                                            afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                            {
                                                                                                                                                                                                                let ddlog_std::tuple4(ref config, ref shadowed_id, ref name, ref shadower_id) = *<ddlog_std::tuple4<ddlog_std::Ref<types__config::NoShadowConfig>, types__ast::AnyId, internment::Intern<String>, types__ast::AnyId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                Some(((ddlog_std::tuple2((*name).clone(), (*shadowed_id).clone())).into_ddvalue(), (ddlog_std::tuple4((*config).clone(), (*shadowed_id).clone(), (*name).clone(), (*shadower_id).clone())).into_ddvalue()))
                                                                                                                                                                                                            }
                                                                                                                                                                                                            __f},
                                                                                                                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                               description: std::borrow::Cow::from("config::EnableNoShadow(.file=file, .config=config), outputs::no_shadow::ScopeOfDecl(.scope=(shadowed_scope@ ast::ScopeId{.id=_, .file=file}), .declared=shadowed_id), outputs::no_shadow::DeclarationInDescendent(.scope=shadowed_scope, .name=name, .id=shadower_id), (shadowed_id != shadower_id), var_decls::VariableDeclarations(.name=name, .scope=shadowed_scope_raw, .declared_in=shadowed_id, .meta=(&var_decls::VariableMeta{.is_function_argument=_, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=shadowed_span}}))"),
                                                                                                                                                                                                                               ffun: None,
                                                                                                                                                                                                                               arrangement: (86,2),
                                                                                                                                                                                                                               jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                               {
                                                                                                                                                                                                                                   let ddlog_std::tuple4(ref config, ref shadowed_id, ref name, ref shadower_id) = *<ddlog_std::tuple4<ddlog_std::Ref<types__config::NoShadowConfig>, types__ast::AnyId, internment::Intern<String>, types__ast::AnyId>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                   let (ref shadowed_scope_raw, ref shadowed_span) = match *<crate::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                       crate::var_decls::VariableDeclarations{name: _, scope: ref shadowed_scope_raw, declared_in: _, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                                                                                                                                                            crate::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ddlog_std::Option::Some{x: shadowed_span}} => ((*shadowed_scope_raw).clone(), (*shadowed_span).clone()),
                                                                                                                                                                                                                                                                                                                                                            _ => return None
                                                                                                                                                                                                                                                                                                                                                        },
                                                                                                                                                                                                                                       _ => return None
                                                                                                                                                                                                                                   };
                                                                                                                                                                                                                                   Some((ddlog_std::tuple6((*config).clone(), (*shadowed_id).clone(), (*name).clone(), (*shadower_id).clone(), (*shadowed_scope_raw).clone(), (*shadowed_span).clone())).into_ddvalue())
                                                                                                                                                                                                                               }
                                                                                                                                                                                                                               __f},
                                                                                                                                                                                                                               next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                                                       description: std::borrow::Cow::from("arrange config::EnableNoShadow(.file=file, .config=config), outputs::no_shadow::ScopeOfDecl(.scope=(shadowed_scope@ ast::ScopeId{.id=_, .file=file}), .declared=shadowed_id), outputs::no_shadow::DeclarationInDescendent(.scope=shadowed_scope, .name=name, .id=shadower_id), (shadowed_id != shadower_id), var_decls::VariableDeclarations(.name=name, .scope=shadowed_scope_raw, .declared_in=shadowed_id, .meta=(&var_decls::VariableMeta{.is_function_argument=_, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=shadowed_span}})) by (name, shadower_id)"),
                                                                                                                                                                                                                                                       afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                                                       {
                                                                                                                                                                                                                                                           let ddlog_std::tuple6(ref config, ref shadowed_id, ref name, ref shadower_id, ref shadowed_scope_raw, ref shadowed_span) = *<ddlog_std::tuple6<ddlog_std::Ref<types__config::NoShadowConfig>, types__ast::AnyId, internment::Intern<String>, types__ast::AnyId, crate::var_decls::DeclarationScope, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                           Some(((ddlog_std::tuple2((*name).clone(), (*shadower_id).clone())).into_ddvalue(), (ddlog_std::tuple6((*config).clone(), (*shadowed_id).clone(), (*name).clone(), (*shadower_id).clone(), (*shadowed_scope_raw).clone(), (*shadowed_span).clone())).into_ddvalue()))
                                                                                                                                                                                                                                                       }
                                                                                                                                                                                                                                                       __f},
                                                                                                                                                                                                                                                       next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                                                                                                          description: std::borrow::Cow::from("config::EnableNoShadow(.file=file, .config=config), outputs::no_shadow::ScopeOfDecl(.scope=(shadowed_scope@ ast::ScopeId{.id=_, .file=file}), .declared=shadowed_id), outputs::no_shadow::DeclarationInDescendent(.scope=shadowed_scope, .name=name, .id=shadower_id), (shadowed_id != shadower_id), var_decls::VariableDeclarations(.name=name, .scope=shadowed_scope_raw, .declared_in=shadowed_id, .meta=(&var_decls::VariableMeta{.is_function_argument=_, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=shadowed_span}})), var_decls::VariableDeclarations(.name=name, .scope=shadower_scope_raw, .declared_in=shadower_id, .meta=(&var_decls::VariableMeta{.is_function_argument=_, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=shadower_span}}))"),
                                                                                                                                                                                                                                                                          ffun: None,
                                                                                                                                                                                                                                                                          arrangement: (86,2),
                                                                                                                                                                                                                                                                          jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                          {
                                                                                                                                                                                                                                                                              let ddlog_std::tuple6(ref config, ref shadowed_id, ref name, ref shadower_id, ref shadowed_scope_raw, ref shadowed_span) = *<ddlog_std::tuple6<ddlog_std::Ref<types__config::NoShadowConfig>, types__ast::AnyId, internment::Intern<String>, types__ast::AnyId, crate::var_decls::DeclarationScope, types__ast::Span>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                                                                                              let (ref shadower_scope_raw, ref shadower_span) = match *<crate::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                                                                                                  crate::var_decls::VariableDeclarations{name: _, scope: ref shadower_scope_raw, declared_in: _, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                                                                                                                                                                                                       crate::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ddlog_std::Option::Some{x: shadower_span}} => ((*shadower_scope_raw).clone(), (*shadower_span).clone()),
                                                                                                                                                                                                                                                                                                                                                                                                       _ => return None
                                                                                                                                                                                                                                                                                                                                                                                                   },
                                                                                                                                                                                                                                                                                  _ => return None
                                                                                                                                                                                                                                                                              };
                                                                                                                                                                                                                                                                              if !match ddlog_std::tuple3(types__config::hoisting_enabled(ddlog_std::deref(config)), crate::var_decls::is_hoistable(shadower_scope_raw), crate::var_decls::is_hoistable(shadowed_scope_raw)) {
                                                                                                                                                                                                                                                                                      ddlog_std::tuple3(true, true, true) => ((&*shadower_span) < (&*shadowed_span)),
                                                                                                                                                                                                                                                                                      ddlog_std::tuple3(true, false, true) => ((&*shadower_span) < (&*shadowed_span)),
                                                                                                                                                                                                                                                                                      ddlog_std::tuple3(true, true, false) => ((&*shadower_span) < (&*shadowed_span)),
                                                                                                                                                                                                                                                                                      ddlog_std::tuple3(_, _, _) => true
                                                                                                                                                                                                                                                                                  } {return None;};
                                                                                                                                                                                                                                                                              Some(((NoShadow{variable: (*name).clone(), original: ddlog_std::tuple2((*shadowed_id).clone(), (*shadowed_span).clone()), shadower: ddlog_std::tuple2((*shadower_id).clone(), (*shadower_span).clone()), implicit: false})).into_ddvalue())
                                                                                                                                                                                                                                                                          }
                                                                                                                                                                                                                                                                          __f},
                                                                                                                                                                                                                                                                          next: Box::new(None)
                                                                                                                                                                                                                                                                      })
                                                                                                                                                                                                                                                   }))
                                                                                                                                                                                                                           })
                                                                                                                                                                                                        }))
                                                                                                                                                                                })
                                                                                                                                                             }))
                                                                                                                                     }
                                                                                                                          });