#![allow(
    path_statements,
    unused_imports,
    non_snake_case,
    non_camel_case_types,
    non_upper_case_globals,
    unused_parens,
    non_shorthand_field_patterns,
    dead_code,
    overflowing_literals,
    unreachable_patterns,
    unused_variables,
    clippy::missing_safety_doc,
    clippy::match_single_binding,
    clippy::ptr_arg,
    clippy::redundant_closure,
    clippy::needless_lifetimes,
    clippy::borrowed_box,
    clippy::map_clone,
    clippy::toplevel_ref_arg,
    clippy::double_parens,
    clippy::collapsible_if,
    clippy::clone_on_copy,
    clippy::unused_unit,
    clippy::deref_addrof,
    clippy::clone_on_copy,
    clippy::needless_return,
    clippy::op_ref,
    clippy::match_like_matches_macro,
    clippy::comparison_chain,
    clippy::len_zero,
    clippy::extra_unused_lifetimes
)]

use ::num::One;
use ::std::ops::Deref;

use ::differential_dataflow::collection;
use ::timely::communication;
use ::timely::dataflow::scopes;
use ::timely::worker;

use ::ddlog_derive::{FromRecord, IntoRecord, Mutator};
use ::differential_datalog::ddval::DDValue;
use ::differential_datalog::ddval::DDValConvert;
use ::differential_datalog::program;
use ::differential_datalog::program::TupleTS;
use ::differential_datalog::program::XFormArrangement;
use ::differential_datalog::program::XFormCollection;
use ::differential_datalog::program::Weight;
use ::differential_datalog::record::FromRecord;
use ::differential_datalog::record::IntoRecord;
use ::differential_datalog::record::Mutator;
use ::serde::Deserialize;
use ::serde::Serialize;


// `usize` and `isize` are builtin Rust types; we therefore declare an alias to DDlog's `usize` and
// `isize`.
pub type std_usize = u64;
pub type std_isize = i64;


#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, IntoRecord, Mutator, Default, Serialize, Deserialize, FromRecord)]
#[ddlog(rename = "outputs::unused_vars::FunctionBodyScope")]
pub struct FunctionBodyScope {
    pub id: types__ast::AnyId,
    pub body: types__ast::ScopeId
}
impl abomonation::Abomonation for FunctionBodyScope{}
impl ::std::fmt::Display for FunctionBodyScope {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            FunctionBodyScope{id,body} => {
                __formatter.write_str("outputs::unused_vars::FunctionBodyScope{")?;
                ::std::fmt::Debug::fmt(id, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(body, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for FunctionBodyScope {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
#[derive(Eq, Ord, Clone, Hash, PartialEq, PartialOrd, IntoRecord, Mutator, Default, Serialize, Deserialize, FromRecord)]
#[ddlog(rename = "outputs::unused_vars::UnusedVariables")]
pub struct UnusedVariables {
    pub name: types__ast::Name,
    pub declared: types__ast::AnyId,
    pub span: types__ast::Span
}
impl abomonation::Abomonation for UnusedVariables{}
impl ::std::fmt::Display for UnusedVariables {
    fn fmt(&self, __formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match self {
            UnusedVariables{name,declared,span} => {
                __formatter.write_str("outputs::unused_vars::UnusedVariables{")?;
                ::std::fmt::Debug::fmt(name, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(declared, __formatter)?;
                __formatter.write_str(",")?;
                ::std::fmt::Debug::fmt(span, __formatter)?;
                __formatter.write_str("}")
            }
        }
    }
}
impl ::std::fmt::Debug for UnusedVariables {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::std::fmt::Display::fmt(&self, f)
    }
}
pub static __Arng_outputs_unused_vars_FunctionBodyScope_0 : ::once_cell::sync::Lazy<program::Arrangement> = ::once_cell::sync::Lazy::new(|| program::Arrangement::Map{
                                                                                                                                               name: std::borrow::Cow::from(r###"(outputs::unused_vars::FunctionBodyScope{.id=(_0: ast::AnyId), .body=(_: ast::ScopeId)}: outputs::unused_vars::FunctionBodyScope) /*join*/"###),
                                                                                                                                                afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                {
                                                                                                                                                    let __cloned = __v.clone();
                                                                                                                                                    match < FunctionBodyScope>::from_ddvalue(__v) {
                                                                                                                                                        FunctionBodyScope{id: ref _0, body: _} => Some(((*_0).clone()).into_ddvalue()),
                                                                                                                                                        _ => None
                                                                                                                                                    }.map(|x|(x,__cloned))
                                                                                                                                                }
                                                                                                                                                __f},
                                                                                                                                                queryable: false
                                                                                                                                            });
pub static __Rule_outputs_unused_vars_FunctionBodyScope_0 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::unused_vars::FunctionBodyScope[(outputs::unused_vars::FunctionBodyScope{.id=(ast::AnyIdFunc{.func=id}: ast::AnyId), .body=body}: outputs::unused_vars::FunctionBodyScope)] :- config::EnableNoUnusedVars[(config::EnableNoUnusedVars{.file=(file: ast::FileId), .config=(config: ddlog_std::Ref<config::NoUnusedVarsConfig>)}: config::EnableNoUnusedVars)], inputs::Function[(inputs::Function{.id=(id@ (ast::FuncId{.id=(_: bit<32>), .file=(file: ast::FileId)}: ast::FuncId)), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .scope=(_: ast::ScopeId), .body=(body: ast::ScopeId), .exported=(_: bool)}: inputs::Function)]. */
                                                                                                                                     program::Rule::ArrangementRule {
                                                                                                                                         description: std::borrow::Cow::from( "outputs::unused_vars::FunctionBodyScope(.id=ast::AnyIdFunc{.func=id}, .body=body) :- config::EnableNoUnusedVars(.file=file, .config=config), inputs::Function(.id=(id@ ast::FuncId{.id=_, .file=file}), .name=_, .scope=_, .body=body, .exported=_)."),
                                                                                                                                         arr: ( 5, 0),
                                                                                                                                         xform: XFormArrangement::Join{
                                                                                                                                                    description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), inputs::Function(.id=(id@ ast::FuncId{.id=_, .file=file}), .name=_, .scope=_, .body=body, .exported=_)"),
                                                                                                                                                    ffun: None,
                                                                                                                                                    arrangement: (33,1),
                                                                                                                                                    jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                    {
                                                                                                                                                        let (ref file, ref config) = match *<types__config::EnableNoUnusedVars>::from_ddvalue_ref(__v1) {
                                                                                                                                                            types__config::EnableNoUnusedVars{file: ref file, config: ref config} => ((*file).clone(), (*config).clone()),
                                                                                                                                                            _ => return None
                                                                                                                                                        };
                                                                                                                                                        let (ref id, ref body) = match *<types__inputs::Function>::from_ddvalue_ref(__v2) {
                                                                                                                                                            types__inputs::Function{id: ref id, name: _, scope: _, body: ref body, exported: _} => match id {
                                                                                                                                                                                                                                                       types__ast::FuncId{id: _, file: _} => ((*id).clone(), (*body).clone()),
                                                                                                                                                                                                                                                       _ => return None
                                                                                                                                                                                                                                                   },
                                                                                                                                                            _ => return None
                                                                                                                                                        };
                                                                                                                                                        Some(((FunctionBodyScope{id: (types__ast::AnyId::AnyIdFunc{func: (*id).clone()}), body: (*body).clone()})).into_ddvalue())
                                                                                                                                                    }
                                                                                                                                                    __f},
                                                                                                                                                    next: Box::new(None)
                                                                                                                                                }
                                                                                                                                     });
pub static __Rule_outputs_unused_vars_FunctionBodyScope_1 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::unused_vars::FunctionBodyScope[(outputs::unused_vars::FunctionBodyScope{.id=(ast::AnyIdExpr{.expr=id}: ast::AnyId), .body=body}: outputs::unused_vars::FunctionBodyScope)] :- config::EnableNoUnusedVars[(config::EnableNoUnusedVars{.file=(file: ast::FileId), .config=(config: ddlog_std::Ref<config::NoUnusedVarsConfig>)}: config::EnableNoUnusedVars)], inputs::Arrow[(inputs::Arrow{.expr_id=(id@ (ast::ExprId{.id=(_: bit<32>), .file=(file: ast::FileId)}: ast::ExprId)), .body=(ddlog_std::Some{.x=((_: ddlog_std::Either<ast::ExprId,ast::StmtId>), (body: ast::ScopeId))}: ddlog_std::Option<(ddlog_std::Either<ast::ExprId,ast::StmtId>, ast::ScopeId)>)}: inputs::Arrow)]. */
                                                                                                                                     program::Rule::ArrangementRule {
                                                                                                                                         description: std::borrow::Cow::from( "outputs::unused_vars::FunctionBodyScope(.id=ast::AnyIdExpr{.expr=id}, .body=body) :- config::EnableNoUnusedVars(.file=file, .config=config), inputs::Arrow(.expr_id=(id@ ast::ExprId{.id=_, .file=file}), .body=ddlog_std::Some{.x=(_, body)})."),
                                                                                                                                         arr: ( 5, 0),
                                                                                                                                         xform: XFormArrangement::Join{
                                                                                                                                                    description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), inputs::Arrow(.expr_id=(id@ ast::ExprId{.id=_, .file=file}), .body=ddlog_std::Some{.x=(_, body)})"),
                                                                                                                                                    ffun: None,
                                                                                                                                                    arrangement: (8,0),
                                                                                                                                                    jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                    {
                                                                                                                                                        let (ref file, ref config) = match *<types__config::EnableNoUnusedVars>::from_ddvalue_ref(__v1) {
                                                                                                                                                            types__config::EnableNoUnusedVars{file: ref file, config: ref config} => ((*file).clone(), (*config).clone()),
                                                                                                                                                            _ => return None
                                                                                                                                                        };
                                                                                                                                                        let (ref id, ref body) = match *<types__inputs::Arrow>::from_ddvalue_ref(__v2) {
                                                                                                                                                            types__inputs::Arrow{expr_id: ref id, body: ddlog_std::Option::Some{x: ddlog_std::tuple2(_, ref body)}} => match id {
                                                                                                                                                                                                                                                                           types__ast::ExprId{id: _, file: _} => ((*id).clone(), (*body).clone()),
                                                                                                                                                                                                                                                                           _ => return None
                                                                                                                                                                                                                                                                       },
                                                                                                                                                            _ => return None
                                                                                                                                                        };
                                                                                                                                                        Some(((FunctionBodyScope{id: (types__ast::AnyId::AnyIdExpr{expr: (*id).clone()}), body: (*body).clone()})).into_ddvalue())
                                                                                                                                                    }
                                                                                                                                                    __f},
                                                                                                                                                    next: Box::new(None)
                                                                                                                                                }
                                                                                                                                     });
pub static __Rule_outputs_unused_vars_FunctionBodyScope_2 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::unused_vars::FunctionBodyScope[(outputs::unused_vars::FunctionBodyScope{.id=(ast::AnyIdExpr{.expr=id}: ast::AnyId), .body=body}: outputs::unused_vars::FunctionBodyScope)] :- config::EnableNoUnusedVars[(config::EnableNoUnusedVars{.file=(file: ast::FileId), .config=(config: ddlog_std::Ref<config::NoUnusedVarsConfig>)}: config::EnableNoUnusedVars)], inputs::InlineFunc[(inputs::InlineFunc{.expr_id=(id@ (ast::ExprId{.id=(_: bit<32>), .file=(file: ast::FileId)}: ast::ExprId)), .name=(_: ddlog_std::Option<ast::Spanned<ast::Name>>), .body=(ddlog_std::Some{.x=(body_id: ast::StmtId)}: ddlog_std::Option<ast::StmtId>)}: inputs::InlineFunc)], inputs::Statement[(inputs::Statement{.id=(body_id: ast::StmtId), .kind=(_: ast::StmtKind), .scope=(body: ast::ScopeId), .span=(_: ast::Span)}: inputs::Statement)]. */
                                                                                                                                     program::Rule::ArrangementRule {
                                                                                                                                         description: std::borrow::Cow::from( "outputs::unused_vars::FunctionBodyScope(.id=ast::AnyIdExpr{.expr=id}, .body=body) :- config::EnableNoUnusedVars(.file=file, .config=config), inputs::InlineFunc(.expr_id=(id@ ast::ExprId{.id=_, .file=file}), .name=_, .body=ddlog_std::Some{.x=body_id}), inputs::Statement(.id=body_id, .kind=_, .scope=body, .span=_)."),
                                                                                                                                         arr: ( 5, 0),
                                                                                                                                         xform: XFormArrangement::Join{
                                                                                                                                                    description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), inputs::InlineFunc(.expr_id=(id@ ast::ExprId{.id=_, .file=file}), .name=_, .body=ddlog_std::Some{.x=body_id})"),
                                                                                                                                                    ffun: None,
                                                                                                                                                    arrangement: (38,0),
                                                                                                                                                    jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                    {
                                                                                                                                                        let (ref file, ref config) = match *<types__config::EnableNoUnusedVars>::from_ddvalue_ref(__v1) {
                                                                                                                                                            types__config::EnableNoUnusedVars{file: ref file, config: ref config} => ((*file).clone(), (*config).clone()),
                                                                                                                                                            _ => return None
                                                                                                                                                        };
                                                                                                                                                        let (ref id, ref body_id) = match *<types__inputs::InlineFunc>::from_ddvalue_ref(__v2) {
                                                                                                                                                            types__inputs::InlineFunc{expr_id: ref id, name: _, body: ddlog_std::Option::Some{x: ref body_id}} => match id {
                                                                                                                                                                                                                                                                      types__ast::ExprId{id: _, file: _} => ((*id).clone(), (*body_id).clone()),
                                                                                                                                                                                                                                                                      _ => return None
                                                                                                                                                                                                                                                                  },
                                                                                                                                                            _ => return None
                                                                                                                                                        };
                                                                                                                                                        Some((ddlog_std::tuple2((*id).clone(), (*body_id).clone())).into_ddvalue())
                                                                                                                                                    }
                                                                                                                                                    __f},
                                                                                                                                                    next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                            description: std::borrow::Cow::from("arrange config::EnableNoUnusedVars(.file=file, .config=config), inputs::InlineFunc(.expr_id=(id@ ast::ExprId{.id=_, .file=file}), .name=_, .body=ddlog_std::Some{.x=body_id}) by (body_id)"),
                                                                                                                                                                            afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                            {
                                                                                                                                                                                let ddlog_std::tuple2(ref id, ref body_id) = *<ddlog_std::tuple2<types__ast::ExprId, types__ast::StmtId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                Some((((*body_id).clone()).into_ddvalue(), ((*id).clone()).into_ddvalue()))
                                                                                                                                                                            }
                                                                                                                                                                            __f},
                                                                                                                                                                            next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                               description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), inputs::InlineFunc(.expr_id=(id@ ast::ExprId{.id=_, .file=file}), .name=_, .body=ddlog_std::Some{.x=body_id}), inputs::Statement(.id=body_id, .kind=_, .scope=body, .span=_)"),
                                                                                                                                                                                               ffun: None,
                                                                                                                                                                                               arrangement: (47,0),
                                                                                                                                                                                               jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                               {
                                                                                                                                                                                                   let ref id = *<types__ast::ExprId>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                   let ref body = match *<types__inputs::Statement>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                       types__inputs::Statement{id: _, kind: _, scope: ref body, span: _} => (*body).clone(),
                                                                                                                                                                                                       _ => return None
                                                                                                                                                                                                   };
                                                                                                                                                                                                   Some(((FunctionBodyScope{id: (types__ast::AnyId::AnyIdExpr{expr: (*id).clone()}), body: (*body).clone()})).into_ddvalue())
                                                                                                                                                                                               }
                                                                                                                                                                                               __f},
                                                                                                                                                                                               next: Box::new(None)
                                                                                                                                                                                           })
                                                                                                                                                                        }))
                                                                                                                                                }
                                                                                                                                     });
pub static __Rule_outputs_unused_vars_UnusedVariables_0 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span}: outputs::unused_vars::UnusedVariables)] :- config::EnableNoUnusedVars[(config::EnableNoUnusedVars{.file=(file: ast::FileId), .config=(config: ddlog_std::Ref<config::NoUnusedVarsConfig>)}: config::EnableNoUnusedVars)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((ast::file(declared)) == (ddlog_std::Some{.x=file}: ddlog_std::Option<ast::FileId>)), (not (regex::regex_set_match((config::ignored_patterns(((ddlog_std::deref: function(ddlog_std::Ref<config::NoUnusedVarsConfig>):config::NoUnusedVarsConfig)(config)))), ((internment::ival: function(internment::Intern<string>):string)(name))))), (not (ast::is_global(declared))), not is_exported::IsExported[(is_exported::IsExported{.id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.name=(name: internment::Intern<string>), .scope=(var_decls::hoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                                                                                                                   program::Rule::ArrangementRule {
                                                                                                                                       description: std::borrow::Cow::from( "outputs::unused_vars::UnusedVariables(.name=name, .declared=declared, .span=span) :- config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), (not (ast::is_global(declared))), not is_exported::IsExported(.id=declared), not name_in_scope::NameInScope(.name=name, .scope=(var_decls::hoisted_scope(scope)), .declared=declared)."),
                                                                                                                                       arr: ( 5, 1),
                                                                                                                                       xform: XFormArrangement::Join{
                                                                                                                                                  description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}}))"),
                                                                                                                                                  ffun: None,
                                                                                                                                                  arrangement: (86,4),
                                                                                                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                  {
                                                                                                                                                      let (ref file, ref config) = match *<types__config::EnableNoUnusedVars>::from_ddvalue_ref(__v1) {
                                                                                                                                                          types__config::EnableNoUnusedVars{file: ref file, config: ref config} => ((*file).clone(), (*config).clone()),
                                                                                                                                                          _ => return None
                                                                                                                                                      };
                                                                                                                                                      let (ref name, ref scope, ref declared, ref span) = match *<crate::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                                          crate::var_decls::VariableDeclarations{name: ref name, scope: ref scope, declared_in: ref declared, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                                                                                    crate::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ddlog_std::Option::Some{x: span}} => ((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone()),
                                                                                                                                                                                                                                                                                    _ => return None
                                                                                                                                                                                                                                                                                },
                                                                                                                                                          _ => return None
                                                                                                                                                      };
                                                                                                                                                      if !((&*(&types__ast::file(declared))) == (&*(&(ddlog_std::Option::Some{x: (*file).clone()})))) {return None;};
                                                                                                                                                      if !(!types__regex::regex_set_match((&types__config::ignored_patterns(ddlog_std::deref(config))), internment::ival(name))) {return None;};
                                                                                                                                                      if !(!types__ast::is_global(declared)) {return None;};
                                                                                                                                                      Some((ddlog_std::tuple4((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue())
                                                                                                                                                  }
                                                                                                                                                  __f},
                                                                                                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                          description: std::borrow::Cow::from("arrange config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), (not (ast::is_global(declared))) by (declared)"),
                                                                                                                                                                          afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                          {
                                                                                                                                                                              let ddlog_std::tuple4(ref name, ref scope, ref declared, ref span) = *<ddlog_std::tuple4<internment::Intern<String>, crate::var_decls::DeclarationScope, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                              Some((((*declared).clone()).into_ddvalue(), (ddlog_std::tuple4((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                                          }
                                                                                                                                                                          __f},
                                                                                                                                                                          next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                             description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), (not (ast::is_global(declared))), not is_exported::IsExported(.id=declared)"),
                                                                                                                                                                                             ffun: None,
                                                                                                                                                                                             arrangement: (60,0),
                                                                                                                                                                                             next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                     description: std::borrow::Cow::from("arrange config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), (not (ast::is_global(declared))), not is_exported::IsExported(.id=declared) by (name, (var_decls::hoisted_scope(scope)), declared)"),
                                                                                                                                                                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                     {
                                                                                                                                                                                                                         let ddlog_std::tuple4(ref name, ref scope, ref declared, ref span) = *<ddlog_std::tuple4<internment::Intern<String>, crate::var_decls::DeclarationScope, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                         Some(((ddlog_std::tuple3((*name).clone(), crate::var_decls::hoisted_scope(scope), (*declared).clone())).into_ddvalue(), (ddlog_std::tuple3((*name).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                     next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                                                                        description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), (not (ast::is_global(declared))), not is_exported::IsExported(.id=declared), not name_in_scope::NameInScope(.name=name, .scope=(var_decls::hoisted_scope(scope)), .declared=declared)"),
                                                                                                                                                                                                                                        ffun: None,
                                                                                                                                                                                                                                        arrangement: (61,5),
                                                                                                                                                                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                                                                                                                description: std::borrow::Cow::from("head of outputs::unused_vars::UnusedVariables(.name=name, .declared=declared, .span=span) :- config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), (not (ast::is_global(declared))), not is_exported::IsExported(.id=declared), not name_in_scope::NameInScope(.name=name, .scope=(var_decls::hoisted_scope(scope)), .declared=declared)."),
                                                                                                                                                                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                    let ddlog_std::tuple3(ref name, ref declared, ref span) = *<ddlog_std::tuple3<internment::Intern<String>, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                    Some(((UnusedVariables{name: (*name).clone(), declared: (*declared).clone(), span: (*span).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                __f},
                                                                                                                                                                                                                                                                next: Box::new(None)
                                                                                                                                                                                                                                                            }))
                                                                                                                                                                                                                                    })
                                                                                                                                                                                                                 }))
                                                                                                                                                                                         })
                                                                                                                                                                      }))
                                                                                                                                              }
                                                                                                                                   });
pub static __Rule_outputs_unused_vars_UnusedVariables_1 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span}: outputs::unused_vars::UnusedVariables)] :- config::EnableNoUnusedVars[(config::EnableNoUnusedVars{.file=(file: ast::FileId), .config=(config: ddlog_std::Ref<config::NoUnusedVarsConfig>)}: config::EnableNoUnusedVars)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.name=(name: internment::Intern<string>), .scope=(_: var_decls::DeclarationScope), .declared_in=(declared: ast::AnyId), .meta=((&(var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((ast::file(declared)) == (ddlog_std::Some{.x=file}: ddlog_std::Option<ast::FileId>)), (not (regex::regex_set_match((config::ignored_patterns(((ddlog_std::deref: function(ddlog_std::Ref<config::NoUnusedVarsConfig>):config::NoUnusedVarsConfig)(config)))), ((internment::ival: function(internment::Intern<string>):string)(name))))), outputs::unused_vars::FunctionBodyScope[(outputs::unused_vars::FunctionBodyScope{.id=(declared: ast::AnyId), .body=(body_scope: ast::ScopeId)}: outputs::unused_vars::FunctionBodyScope)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.name=(name: internment::Intern<string>), .scope=(body_scope: ast::ScopeId), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                                                                                                                   program::Rule::ArrangementRule {
                                                                                                                                       description: std::borrow::Cow::from( "outputs::unused_vars::UnusedVariables(.name=name, .declared=declared, .span=span) :- config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), outputs::unused_vars::FunctionBodyScope(.id=declared, .body=body_scope), not name_in_scope::NameInScope(.name=name, .scope=body_scope, .declared=declared)."),
                                                                                                                                       arr: ( 5, 1),
                                                                                                                                       xform: XFormArrangement::Join{
                                                                                                                                                  description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}}))"),
                                                                                                                                                  ffun: None,
                                                                                                                                                  arrangement: (86,5),
                                                                                                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                  {
                                                                                                                                                      let (ref file, ref config) = match *<types__config::EnableNoUnusedVars>::from_ddvalue_ref(__v1) {
                                                                                                                                                          types__config::EnableNoUnusedVars{file: ref file, config: ref config} => ((*file).clone(), (*config).clone()),
                                                                                                                                                          _ => return None
                                                                                                                                                      };
                                                                                                                                                      let (ref name, ref declared, ref span) = match *<crate::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                                          crate::var_decls::VariableDeclarations{name: ref name, scope: _, declared_in: ref declared, meta: ref _0_} => match ((*_0_)).deref() {
                                                                                                                                                                                                                                                                            crate::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ddlog_std::Option::Some{x: span}} => ((*name).clone(), (*declared).clone(), (*span).clone()),
                                                                                                                                                                                                                                                                            _ => return None
                                                                                                                                                                                                                                                                        },
                                                                                                                                                          _ => return None
                                                                                                                                                      };
                                                                                                                                                      if !((&*(&types__ast::file(declared))) == (&*(&(ddlog_std::Option::Some{x: (*file).clone()})))) {return None;};
                                                                                                                                                      if !(!types__regex::regex_set_match((&types__config::ignored_patterns(ddlog_std::deref(config))), internment::ival(name))) {return None;};
                                                                                                                                                      Some((ddlog_std::tuple3((*name).clone(), (*declared).clone(), (*span).clone())).into_ddvalue())
                                                                                                                                                  }
                                                                                                                                                  __f},
                                                                                                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                          description: std::borrow::Cow::from("arrange config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))) by (declared)"),
                                                                                                                                                                          afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                          {
                                                                                                                                                                              let ddlog_std::tuple3(ref name, ref declared, ref span) = *<ddlog_std::tuple3<internment::Intern<String>, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                              Some((((*declared).clone()).into_ddvalue(), (ddlog_std::tuple3((*name).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                                          }
                                                                                                                                                                          __f},
                                                                                                                                                                          next: Box::new(XFormArrangement::Join{
                                                                                                                                                                                             description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), outputs::unused_vars::FunctionBodyScope(.id=declared, .body=body_scope)"),
                                                                                                                                                                                             ffun: None,
                                                                                                                                                                                             arrangement: (78,0),
                                                                                                                                                                                             jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                                                             {
                                                                                                                                                                                                 let ddlog_std::tuple3(ref name, ref declared, ref span) = *<ddlog_std::tuple3<internment::Intern<String>, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( __v1 );
                                                                                                                                                                                                 let ref body_scope = match *<FunctionBodyScope>::from_ddvalue_ref(__v2) {
                                                                                                                                                                                                     FunctionBodyScope{id: _, body: ref body_scope} => (*body_scope).clone(),
                                                                                                                                                                                                     _ => return None
                                                                                                                                                                                                 };
                                                                                                                                                                                                 Some((ddlog_std::tuple4((*name).clone(), (*declared).clone(), (*span).clone(), (*body_scope).clone())).into_ddvalue())
                                                                                                                                                                                             }
                                                                                                                                                                                             __f},
                                                                                                                                                                                             next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                     description: std::borrow::Cow::from("arrange config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), outputs::unused_vars::FunctionBodyScope(.id=declared, .body=body_scope) by (name, body_scope, declared)"),
                                                                                                                                                                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                     {
                                                                                                                                                                                                                         let ddlog_std::tuple4(ref name, ref declared, ref span, ref body_scope) = *<ddlog_std::tuple4<internment::Intern<String>, types__ast::AnyId, types__ast::Span, types__ast::ScopeId>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                         Some(((ddlog_std::tuple3((*name).clone(), (*body_scope).clone(), (*declared).clone())).into_ddvalue(), (ddlog_std::tuple3((*name).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                     next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                                                                        description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), outputs::unused_vars::FunctionBodyScope(.id=declared, .body=body_scope), not name_in_scope::NameInScope(.name=name, .scope=body_scope, .declared=declared)"),
                                                                                                                                                                                                                                        ffun: None,
                                                                                                                                                                                                                                        arrangement: (61,6),
                                                                                                                                                                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                                                                                                                description: std::borrow::Cow::from("head of outputs::unused_vars::UnusedVariables(.name=name, .declared=declared, .span=span) :- config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=_, .declared_in=declared, .meta=(&var_decls::VariableMeta{.is_function_argument=true, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), outputs::unused_vars::FunctionBodyScope(.id=declared, .body=body_scope), not name_in_scope::NameInScope(.name=name, .scope=body_scope, .declared=declared)."),
                                                                                                                                                                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                    let ddlog_std::tuple3(ref name, ref declared, ref span) = *<ddlog_std::tuple3<internment::Intern<String>, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                    Some(((UnusedVariables{name: (*name).clone(), declared: (*declared).clone(), span: (*span).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                __f},
                                                                                                                                                                                                                                                                next: Box::new(None)
                                                                                                                                                                                                                                                            }))
                                                                                                                                                                                                                                    })
                                                                                                                                                                                                                 }))
                                                                                                                                                                                         })
                                                                                                                                                                      }))
                                                                                                                                              }
                                                                                                                                   });
pub static __Rule_outputs_unused_vars_UnusedVariables_2 : ::once_cell::sync::Lazy<program::Rule> = ::once_cell::sync::Lazy::new(|| /* outputs::unused_vars::UnusedVariables[(outputs::unused_vars::UnusedVariables{.name=name, .declared=declared, .span=span}: outputs::unused_vars::UnusedVariables)] :- config::EnableNoUnusedVars[(config::EnableNoUnusedVars{.file=(file: ast::FileId), .config=(config: ddlog_std::Ref<config::NoUnusedVarsConfig>)}: config::EnableNoUnusedVars)], var_decls::VariableDeclarations[(var_decls::VariableDeclarations{.name=(name: internment::Intern<string>), .scope=(scope: var_decls::DeclarationScope), .declared_in=(declared@ (ast::AnyIdGlobal{.global=(_: ast::GlobalId)}: ast::AnyId)), .meta=((&(var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=(ddlog_std::Some{.x=(span: ast::Span)}: ddlog_std::Option<ast::Span>)}: var_decls::VariableMeta)): ddlog_std::Ref<var_decls::VariableMeta>)}: var_decls::VariableDeclarations)], ((ast::file(declared)) == (ddlog_std::Some{.x=file}: ddlog_std::Option<ast::FileId>)), (not (regex::regex_set_match((config::ignored_patterns(((ddlog_std::deref: function(ddlog_std::Ref<config::NoUnusedVarsConfig>):config::NoUnusedVarsConfig)(config)))), ((internment::ival: function(internment::Intern<string>):string)(name))))), not is_exported::IsExported[(is_exported::IsExported{.id=(declared: ast::AnyId)}: is_exported::IsExported)], not name_in_scope::NameInScope[(name_in_scope::NameInScope{.name=(name: internment::Intern<string>), .scope=(var_decls::unhoisted_scope(scope)), .declared=(declared: ast::AnyId)}: name_in_scope::NameInScope)]. */
                                                                                                                                   program::Rule::ArrangementRule {
                                                                                                                                       description: std::borrow::Cow::from( "outputs::unused_vars::UnusedVariables(.name=name, .declared=declared, .span=span) :- config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=(declared@ ast::AnyIdGlobal{.global=_}), .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), not is_exported::IsExported(.id=declared), not name_in_scope::NameInScope(.name=name, .scope=(var_decls::unhoisted_scope(scope)), .declared=declared)."),
                                                                                                                                       arr: ( 5, 1),
                                                                                                                                       xform: XFormArrangement::Join{
                                                                                                                                                  description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=(declared@ ast::AnyIdGlobal{.global=_}), .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}}))"),
                                                                                                                                                  ffun: None,
                                                                                                                                                  arrangement: (86,6),
                                                                                                                                                  jfun: {fn __f(_: &DDValue ,__v1: &DDValue,__v2: &DDValue) -> Option<DDValue>
                                                                                                                                                  {
                                                                                                                                                      let (ref file, ref config) = match *<types__config::EnableNoUnusedVars>::from_ddvalue_ref(__v1) {
                                                                                                                                                          types__config::EnableNoUnusedVars{file: ref file, config: ref config} => ((*file).clone(), (*config).clone()),
                                                                                                                                                          _ => return None
                                                                                                                                                      };
                                                                                                                                                      let (ref name, ref scope, ref declared, ref span) = match *<crate::var_decls::VariableDeclarations>::from_ddvalue_ref(__v2) {
                                                                                                                                                          crate::var_decls::VariableDeclarations{name: ref name, scope: ref scope, declared_in: ref declared, meta: ref _0_} => match declared {
                                                                                                                                                                                                                                                                                    types__ast::AnyId::AnyIdGlobal{global: _} => match ((*_0_)).deref() {
                                                                                                                                                                                                                                                                                                                                     crate::var_decls::VariableMeta{is_function_argument: _, implicitly_declared: _, declaration_span: ddlog_std::Option::Some{x: span}} => ((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone()),
                                                                                                                                                                                                                                                                                                                                     _ => return None
                                                                                                                                                                                                                                                                                                                                 },
                                                                                                                                                                                                                                                                                    _ => return None
                                                                                                                                                                                                                                                                                },
                                                                                                                                                          _ => return None
                                                                                                                                                      };
                                                                                                                                                      if !((&*(&types__ast::file(declared))) == (&*(&(ddlog_std::Option::Some{x: (*file).clone()})))) {return None;};
                                                                                                                                                      if !(!types__regex::regex_set_match((&types__config::ignored_patterns(ddlog_std::deref(config))), internment::ival(name))) {return None;};
                                                                                                                                                      Some((ddlog_std::tuple4((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue())
                                                                                                                                                  }
                                                                                                                                                  __f},
                                                                                                                                                  next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                          description: std::borrow::Cow::from("arrange config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=(declared@ ast::AnyIdGlobal{.global=_}), .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))) by (declared)"),
                                                                                                                                                                          afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                          {
                                                                                                                                                                              let ddlog_std::tuple4(ref name, ref scope, ref declared, ref span) = *<ddlog_std::tuple4<internment::Intern<String>, crate::var_decls::DeclarationScope, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                              Some((((*declared).clone()).into_ddvalue(), (ddlog_std::tuple4((*name).clone(), (*scope).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                                          }
                                                                                                                                                                          __f},
                                                                                                                                                                          next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                             description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=(declared@ ast::AnyIdGlobal{.global=_}), .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), not is_exported::IsExported(.id=declared)"),
                                                                                                                                                                                             ffun: None,
                                                                                                                                                                                             arrangement: (60,0),
                                                                                                                                                                                             next: Box::new(Some(XFormCollection::Arrange {
                                                                                                                                                                                                                     description: std::borrow::Cow::from("arrange config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=(declared@ ast::AnyIdGlobal{.global=_}), .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), not is_exported::IsExported(.id=declared) by (name, (var_decls::unhoisted_scope(scope)), declared)"),
                                                                                                                                                                                                                     afun: {fn __f(__v: DDValue) -> Option<(DDValue,DDValue)>
                                                                                                                                                                                                                     {
                                                                                                                                                                                                                         let ddlog_std::tuple4(ref name, ref scope, ref declared, ref span) = *<ddlog_std::tuple4<internment::Intern<String>, crate::var_decls::DeclarationScope, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                         Some(((ddlog_std::tuple3((*name).clone(), crate::var_decls::unhoisted_scope(scope), (*declared).clone())).into_ddvalue(), (ddlog_std::tuple3((*name).clone(), (*declared).clone(), (*span).clone())).into_ddvalue()))
                                                                                                                                                                                                                     }
                                                                                                                                                                                                                     __f},
                                                                                                                                                                                                                     next: Box::new(XFormArrangement::Antijoin {
                                                                                                                                                                                                                                        description: std::borrow::Cow::from("config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=(declared@ ast::AnyIdGlobal{.global=_}), .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), not is_exported::IsExported(.id=declared), not name_in_scope::NameInScope(.name=name, .scope=(var_decls::unhoisted_scope(scope)), .declared=declared)"),
                                                                                                                                                                                                                                        ffun: None,
                                                                                                                                                                                                                                        arrangement: (61,5),
                                                                                                                                                                                                                                        next: Box::new(Some(XFormCollection::FilterMap{
                                                                                                                                                                                                                                                                description: std::borrow::Cow::from("head of outputs::unused_vars::UnusedVariables(.name=name, .declared=declared, .span=span) :- config::EnableNoUnusedVars(.file=file, .config=config), var_decls::VariableDeclarations(.name=name, .scope=scope, .declared_in=(declared@ ast::AnyIdGlobal{.global=_}), .meta=(&var_decls::VariableMeta{.is_function_argument=false, .implicitly_declared=false, .declaration_span=ddlog_std::Some{.x=span}})), ((ast::file(declared)) == ddlog_std::Some{.x=file}), (not (regex::regex_set_match((config::ignored_patterns((ddlog_std::deref(config)))), (internment::ival(name))))), not is_exported::IsExported(.id=declared), not name_in_scope::NameInScope(.name=name, .scope=(var_decls::unhoisted_scope(scope)), .declared=declared)."),
                                                                                                                                                                                                                                                                fmfun: {fn __f(__v: DDValue) -> Option<DDValue>
                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                    let ddlog_std::tuple3(ref name, ref declared, ref span) = *<ddlog_std::tuple3<internment::Intern<String>, types__ast::AnyId, types__ast::Span>>::from_ddvalue_ref( &__v );
                                                                                                                                                                                                                                                                    Some(((UnusedVariables{name: (*name).clone(), declared: (*declared).clone(), span: (*span).clone()})).into_ddvalue())
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                __f},
                                                                                                                                                                                                                                                                next: Box::new(None)
                                                                                                                                                                                                                                                            }))
                                                                                                                                                                                                                                    })
                                                                                                                                                                                                                 }))
                                                                                                                                                                                         })
                                                                                                                                                                      }))
                                                                                                                                              }
                                                                                                                                   });